namespace Lab1PD.Project
{
    /// <summary>
    /// CursorListProject
    /// ================================
    /// 
    /// -------------------------------
    /// 1) Поля класса:
    /// -------------------------------
    /// - nodes: массив структур CursorNode<T>, где каждый узел хранит:
    ///     * Data: данные элемента
    ///     * Next: индекс следующего узла
    ///     * Prev: индекс предыдущего узла
    ///     * Used: флаг занятости (true = ячейка используется)
    /// - head: индекс первого элемента списка (или -1, если пусто)
    /// - tail: индекс последнего элемента (или -1, если пусто)
    /// - count: количество элементов в списке
    /// - capacity: размер массива nodes (по умолчанию 100)
    /// 
    /// -------------------------------
    /// 2) Конструктор:
    /// -------------------------------
    /// - создаёт массив фиксированного размера
    /// - head = -1, tail = -1 (список пуст)
    /// - count = 0
    /// 
    /// -------------------------------
    /// Методы:
    /// -------------------------------
    /// 
    /// End():
    /// - возвращает позицию после последнего элемента
    /// - равна count + 1
    /// 
    /// Insert(x, p):
    /// - вставляет элемент x на позицию p
    /// - шаги:
    ///   1. Проверяем, что p корректна (от 1 до count+1)
    ///   2. Ищем свободную ячейку массива (FindFree)
    ///   3. Заполняем узел данными
    ///   4. Если список пуст:
    ///        * head и tail указывают на новый узел
    ///        * Next и Prev = -1
    ///      Если вставка в начало:
    ///        * новый узел становится head
    ///        * его Next = старый head
    ///        * у старого head обновляем Prev
    ///      Если вставка в конец:
    ///        * новый узел становится tail
    ///        * его Prev = старый tail
    ///        * у старого tail обновляем Next
    ///      Если вставка в середину:
    ///        * находим элемент на позиции p
    ///        * связываем новый узел между prev и current
    ///   5. Увеличиваем count
    /// 
    /// Locate(x):
    /// - ищет элемент по значению x
    /// - идём от head по Next
    /// - если нашли совпадение → возвращаем позицию
    /// - если дошли до конца → возвращаем End()
    /// - сложность O(n)
    /// 
    /// Retrieve(p):
    /// - возвращает значение узла на позиции p
    /// - шаги:
    ///   1. Проверяем корректность позиции
    ///   2. Идём от head по Next до нужной позиции
    ///   3. Возвращаем Data
    /// 
    /// Delete(p):
    /// - удаляет элемент на позиции p
    /// - шаги:
    ///   1. Проверяем корректность позиции
    ///   2. Идём до p-го узла
    ///   3. Получаем его Prev и Next
    ///   4. Если Prev != -1 → связываем Prev.Next = Next
    ///      Иначе head = Next (если удаляем первый)
    ///   5. Если Next != -1 → связываем Next.Prev = Prev
    ///      Иначе tail = Prev (если удаляем последний)
    ///   6. Помечаем ячейку как свободную (Used = false)
    ///   7. Уменьшаем count
    /// 
    /// Next(p):
    /// - возвращает p + 1 (следующую позицию)
    /// - если p последний → возвращает End()
    /// 
    /// Previous(p):
    /// - возвращает p - 1 (предыдущую позицию)
    /// - если p = 1 → выбрасывается исключение (нет предыдущего элемента)
    /// 
    /// Makenull():
    /// - очищает список
    /// - head = -1, tail = -1, count = 0
    /// - пересоздаём массив nodes
    /// - возвращает End()
    /// 
    /// First():
    /// - возвращает позицию первого элемента (1)
    /// - если список пуст → End()
    /// 
    /// PrintList():
    /// - начиная с head, идём по цепочке Next
    /// - печатаем Data каждого узла
    /// - завершаем, когда текущий индекс = -1
    /// 
    /// -------------------------------
    /// Вспомогательный struct CursorNode<T>:
    /// -------------------------------
    /// - Data: данные
    /// - Next: индекс следующего элемента
    /// - Prev: индекс предыдущего
    /// - Used: занята ли ячейка
    /// 
    /// -------------------------------
    /// Отличие от двусвязного списка:
    /// -------------------------------
    /// - здесь вместо ссылок используются индексы массива
    /// - память под узлы выделяется заранее (capacity)
    /// - освобождение узла = пометка Used = false
    /// 
    /// </summary>
    public class CursorListProject
    {
        // Здесь нет кода, только описание алгоритмов выше.
    }
}
