# Описание алгоритмов

## Двуcвязный список (DoubleLinkedList)

### Устройство

* **Элемент (узел)** хранит:

    * `Data` — данные
    * `Prev` — ссылка на предыдущий элемент
    * `Next` — ссылка на следующий элемент
* Вся структура — это цепочка узлов, связанных между собой через ссылки.
* `head` указывает на первый элемент, `tail` — на последний.

### Алгоритмы

1. **Insert**

    * Вставка в начало → меняем `head`, связываем новый узел со старым.
    * Вставка в конец → цепляем к `tail`.
    * Вставка в середину → ищем нужный узел и переставляем ссылки.
    * * Важно: все операции выполняются за **O(1)** (кроме поиска места вставки — O(n)).

2. **Delete**

    * Находим узел по позиции.
    * «Выкидываем» его из цепочки, переподключив `Prev` и `Next`.
    * * Удаление за **O(1)** (при известном узле).

3. **Retrieve / Locate**

    * Проход по цепочке от `head` или `tail`.
    * Поиск по позиции или по значению.
    * * Сложность **O(n)**.

4. **Навигация (Next/Previous)**

    * Перемещение по ссылкам очень быстрое: O(1).

---

### Преимущества

* Гибкость: можно быстро вставлять и удалять элементы в любом месте.
* Неограниченный размер (растёт динамически).
* Есть ссылки вперёд и назад → удобно перемещаться.

### Недостатки

* **Память**: на каждый узел хранится 2 дополнительных ссылки (`Prev`, `Next`).
* **Фрагментация**: узлы лежат где угодно в памяти, нет локальности данных (медленнее для кэша CPU).
* **Нельзя прямой доступ по индексу** → только последовательный обход.

---

## Список на курсорах (CursorList)

### Устройство

* Вместо «ссылок» используются **индексы массива**.
* В памяти есть массив `nodes[capacity]`.
* Каждый `CursorNode` хранит:

    * `Data`
    * `Prev` — индекс предыдущего
    * `Next` — индекс следующего
    * `Used` — занята ли ячейка
* `head` = индекс первого элемента, `tail` = индекс последнего.
* «Свободные» ячейки помечаются `Used = false` и могут использоваться повторно.

---

### Алгоритмы

1. **Insert**

    * Берём свободную ячейку массива (`FindFree`).
    * Заполняем её данными.
    * Настраиваем `Next` и `Prev` у соседей.
    * * Сложность: поиск позиции O(n), сама вставка O(1).

2. **Delete**

    * Ищем узел по позиции.
    * «Отключаем» его, переставив индексы соседей.
    * Помечаем `Used = false`.
    * * Сложность: O(n) из-за поиска позиции.

3. **Retrieve / Locate**

    * Поиск по индексу или значению.
    * * Сложность: O(n).

4. **Навигация (Next/Previous)**

    * Через индексы, как в массиве → O(1).

---

### Преимущества

* Работает даже в языках **без указателей** (например, Pascal).
* Данные хранятся в массиве → **локальность памяти** (лучше для кэша).
* Контролируем использование памяти (capacity фиксирован заранее).

### Недостатки

* Ограниченный размер (capacity).
* Операции `Insert/Delete` сложнее, т.к. нужно искать свободную ячейку.
* При большом числе вставок/удалений возможна «дыра» в массиве (Used = false).

---

## Сравнение

| Характеристика            | Двусвязный список       | Список на курсорах               |
| ------------------------- | ----------------------- | -------------------------------- |
| Хранение                  | Узлы в памяти (heap)    | Массив фиксированной длины       |
| Ссылки                    | Указатели               | Индексы (целые числа)            |
| Вставка/удаление          | O(1) при известном узле | O(1) (но поиск свободной ячейки) |
| Поиск по позиции/значению | O(n)                    | O(n)                             |
| Локальность данных        | Плохая (разбросано)     | Хорошая (в массиве)              |
| Размер                    | Динамический            | Заранее фиксированный            |
| Использование памяти      | +доп. поля Prev/Next    | +флаг Used                       |
